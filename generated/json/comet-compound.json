{
  "categories": [],
  "content": "Into to Comet smart contracts, deployments and configurator",
  "created": "2023-03-05T13:53:16.846Z",
  "guideIntegrations": {
    "discordRoleIds": []
  },
  "guideType": "course",
  "key": "comet-compound",
  "name": "Comet Protocol",
  "publishStatus": "Live",
  "showIncorrectOnCompletion": true,
  "steps": [
    {
      "content": "## Compound III\nCompound III is a computer program that holds a lot of money. People can suggest changes to how the program works, but these changes can make the program less secure. To make sure the program stays safe, developers need to write tests that check if the new code works well and doesn't have any weaknesses. Companies like OpenZeppelin, ChainSecurity, and Certora also help to make sure the program is safe.\n\nThis guide explains how to make changes to the Compound III program safely. It talks about things like creating tests for the new code, running tests to make sure everything works, and using a tool called GitHub Actions to help with testing. The guide also explains how the program is set up, how to make changes to it, and how to make sure the changes are safe before they are added to the program.\n\n## Architecture\n### Comet protocol\n\n### Tests\n\n### Configurator\nThe Configurator is a special contract that manages all the settings for the Compound III protocol. It's important to be careful when making changes to the protocol, because even small changes can have big consequences. To make changes safely, developers need to write tests, scenarios, and migration scripts.\n\n### Github Actions\nA workflow is a set of tasks that can run automatically to check new code changes. GitHub Actions is a tool that can be used to run these workflows. Developers should make sure their code changes pass all the tests and checks before proposing any changes to the protocol.\n\n",
      "name": "Introduction",
      "stepItems": [],
      "uuid": "3b2af085-1e55-4e13-8f79-9b858692916d"
    },
    {
      "content": "## Comet Contracts\nThe Comet protocol is made up of different contracts that work together to create a system for exchanging a digital asset called Comet.\n\nThe main contract, `Comet.sol`, is responsible for most of Comet's core functionalities. It uses another contract, `CometExt.sol`, for functions that don't fit within Comet.sol.\n\n`CometInterface.sol` is an abstract contract that contains all the functions and events for `Comet.sol` and `CometExt.sol` and is compatible with ERC-20.\n\nThe `Configurator` contracts manage Comet's configurations and deploy new implementations of Comet.\n\nThere are some supplementary contracts like `Bulker.sol`, which allows multiple Comet functions to be called in a single transaction, and CometRewards.sol, which allows users to claim rewards based on their protocol participation.\n\nFinally, there are Vendor contracts like `ConfiguratorProxy.sol` and `CometProxyAdmin.sol`, which inherit from OZ proxies and are used to deploy and upgrade Comet.\n\n## Scenario Tests\n\nScenarios are tests that check if Comet protocol is working correctly. To run these tests, you use a tool called Hardhat. You can run different scenarios against different versions of the Comet protocol. You can also change the number of workers, which can make the tests run faster.\n\nTo run the scenarios, Hardhat plugin is used. The command `npx hardhat scenario` is used to run the tests. You can also run scenarios against different versions of the Comet protocol using the `--bases` option. Additionally, the `--workers` option can be used to change the number of workers to speed up the testing process. Before we can run all the tests, we need to set some environment variables will be used to fetch existing data from supported blockchains.\n\n`npx hardhat scenario --bases development,goerli,fuji`\n\nTo add a new test, you create a new file in a folder called \"scenario\". You then write the test in the file using a programming language called TypeScript. The test checks that a specific feature of the Comet protocol works correctly.\n\nAll the steps are explained in detail [here](https://github.com/compound-finance/comet/blob/main/SCENARIO.md)\n\nSometimes, a scenario requires the most recent version of the Comet contract. In this case, you add a \"constraint\" to the scenario that says it needs to use the most recent version. This makes sure that the scenario can run on any network, even if some features are not available.",
      "name": "Contracts and Tests",
      "stepItems": [],
      "uuid": "0743e67a-b458-4aab-b057-646ef4f96b44"
    },
    {
      "content": "## Enable Workflows and Add Secrets\nAfter we update the code and add the tests, the first thing we need to do is run our scenarios in our CI workflow. To do this, we need to commit our code and push it to GitHub. For the forked comet repo we need to first enable the workflows. The workflows in the forked repository run independently from the official repository.\n\nWe will also need to add the same environment variables as Actions secrets in the repository.\n\nAfter adding all the keys, we can run the workflows in our fork. It's a good idea to run tests in our fork CI before opening a pull request on the official Comet repository. If our branch is up to date, all passing tests in the fork CI will result in passing tests in the pull request to main.\n\n## Run workflow\nWe can click the Actions tab in forked github repo and select the Run Scenarios workflow on the left. We click the Run workflow button on the right, select our branch in the dropdown menu, and then click the green Run workflow button. It will take several minutes to run. \n\n![](https://d31h13bdjwgzxs.cloudfront.net/academy/compound-eth-1/Guide/comet-compound/comet_workflow.png)\n\nLastly, we should consider that scenarios will check existing pending on-chain governance proposals against the test to make sure there are no conflicts caused. This might be the cause of a failing scenario that previously succeeded, even when no code changes have been made in the interim.\n\nNow that we know how to write a scenario test, run it locally, and run it in CI, we can delete this branch and apply what we learned to a Compound III migration script.",
      "name": "Continuous Integration",
      "stepItems": [],
      "uuid": "20bda8f8-ca1a-4bc8-bdde-815d71401f36"
    },
    {
      "content": "Migrations are scripts that are used to deploy or modify contracts in a systematic way. The purpose of migration scripts is to make sure that users can see potential changes that are run prior to creating a governance proposal. In other words, it's a way to prepare for governance changes by showing everyone what changes will be made to the code before actually implementing them.\n\nTo create a migration, you can use the command `yarn hardhat gen:migration` followed by the network and deployment options. There are two methods that needs to be implemented in a migration script: \n1. `prepare` - which creates artifacts like new on-chain contracts\n2. `enact` - which makes these artifacts current, such as upgrading the proxy to the address from the previous step.\n\n```javascript\nenact: async (deploymentManager: DeploymentManager) => {\n    const trace = deploymentManager.tracer();\n    const ethers = deploymentManager.hre.ethers;\n\n    const {\n      governor,\n      comet,\n      configurator,\n      cometAdmin,\n      WETH,\n    } = await deploymentManager.getContracts();\n\n    const actions = [\n      // 1. Increase supply cap for WETH\n      {\n        contract: configurator,\n        signature: \"updateAssetSupplyCap(address,address,uint128)\",\n        args: [comet.address, WETH.address, exp(150_000, 18)],\n      },\n\n      // 2. Deploy and upgrade to a new version of Comet\n      {\n        contract: cometAdmin,\n        signature: \"deployAndUpgradeTo(address,address)\",\n        args: [configurator.address, comet.address],\n      },\n    ];\n    const description = \"# Increase WETH Supply Cap in cUSDCv3\\n\"\n    const txn = await deploymentManager.retry(\n      async () => trace((await governor.propose(...await proposal(actions, description))))\n    );\n\n    const event = txn.events.find(event => event.event === 'ProposalCreated');\n    const [proposalId] = event.args;\n\n    trace(`Created proposal ${proposalId}.`);\n  }\n```\n\nYou can run a migration locally using `yarn hardhat migrate` and specifying the network, deployment, and whether to prepare or enact the migration. You can also simulate either of the previous steps without actually modifying the on-chain state.\n\nHere is the interface which describes the migration actions\n\n```javascript\nexport interface Actions<T> {\n  prepare: (dm: DeploymentManager) => Promise<T>;\n  enact: (dm: DeploymentManager, t: T) => Promise<void>;\n  enacted?: (dm: DeploymentManager) => Promise<boolean>;\n  verify?: (dm: DeploymentManager) => Promise<void>;\n}\n``` \n\nThe preferred way to run a migration is in GitHub, via manual workflow dispatch, which allows everyone to see the exact code that was deployed or run. After preparation, a migration stores some artifacts which can be loaded and referenced in the enact step of that migration.\n\nOnce a migration has been created, the next step is to create a pull request on GitHub and get it reviewed, approved, and enacted before merging it. If the migration creates a governance proposal on-chain, then wait until the proposal either executes or fails before merging the pull request.",
      "name": "Migrations",
      "stepItems": [],
      "uuid": "73a81735-14c4-426c-8bd8-950b6e0a2bbf"
    },
    {
      "content": "",
      "name": "Step 5",
      "stepItems": [],
      "uuid": "d9acccfb-0962-4800-aee7-cb9d16494635"
    }
  ],
  "thumbnail": "https://d31h13bdjwgzxs.cloudfront.net/academy/compound/compound_comet.png",
  "uuid": "comet-compound"
}