{
  "categories": [],
  "content": "Into to Comet smart contracts, deployments and configurator",
  "created": "2023-03-04T20:55:14.868Z",
  "guideIntegrations": {
    "discordRoleIds": []
  },
  "guideType": "course",
  "key": "comet-compound",
  "name": "Comet Protocol",
  "publishStatus": "Live",
  "showIncorrectOnCompletion": true,
  "steps": [
    {
      "content": "## Compound III\nCompound III is a computer program that holds a lot of money. People can suggest changes to how the program works, but these changes can make the program less secure. To make sure the program stays safe, developers need to write tests that check if the new code works well and doesn't have any weaknesses. Companies like OpenZeppelin, ChainSecurity, and Certora also help to make sure the program is safe.\n\nThis guide explains how to make changes to the Compound III program safely. It talks about things like creating tests for the new code, running tests to make sure everything works, and using a tool called GitHub Actions to help with testing. The guide also explains how the program is set up, how to make changes to it, and how to make sure the changes are safe before they are added to the program.\n\n## Architecture\n### Comet protocol\n\n### Tests\n\n### Configurator\nThe Configurator is a special contract that manages all the settings for the Compound III protocol. It's important to be careful when making changes to the protocol, because even small changes can have big consequences. To make changes safely, developers need to write tests, scenarios, and migration scripts.\n\n### Github Actions\nA workflow is a set of tasks that can run automatically to check new code changes. GitHub Actions is a tool that can be used to run these workflows. Developers should make sure their code changes pass all the tests and checks before proposing any changes to the protocol.\n\n",
      "name": "Introduction",
      "stepItems": [],
      "uuid": "3b2af085-1e55-4e13-8f79-9b858692916d"
    },
    {
      "content": "The Scenario Hardhat 2 plugin is a tool that helps test smart contract functions to ensure they work properly. Before we can run all the tests, we need to set some environment variables that the tool will use to fetch existing data from supported blockchains. Once we have set the API keys, we can run all the tests with a single command.\n\nTo create a new test scenario, we need to create a new file and write the code for the actions we want to test. In this example, we will create a scenario that adds a new type of collateral to the smart contract. We will test this scenario on the Ethereum mainnet.\n\nThe scenario will perform a few actions on the blockchain, such as importing an existing token, moving tokens to a test account, and adding the token as collateral. We can then test that the balances are correct.\n\nIt's important to note that scenarios should be added when introducing a fundamentally new protocol feature and should always pass in all deployments of the protocol. However, the scenario we will create in this example is just for educational purposes.\n\nWe can run our scenario locally to make sure it works as intended. We can also run all the scenarios by removing the \".only\" method before checking in the code.",
      "name": "Add Scenarios",
      "stepItems": [],
      "uuid": "0743e67a-b458-4aab-b057-646ef4f96b44"
    },
    {
      "content": "So, the first thing we need to do is run our scenarios in our CI workflow. To do this, we need to commit our code and push it to GitHub. We'll delete it later after we learn how to use workflows. Then, we go back to the forked Comet repo in GitHub and click on the Actions tab at the top of the page. We then click the green button that says \"I understand my workflows\" and enable them. This sets up the same workflows defined in the official Comet repository when we forked it. We can run them independently from the official repository.\n\nNext, we need to add the same environment variables as Actions secrets in the repository, like we did for the command line earlier. We click on the Settings tab on the top right, then Secrets on the bottom left, then Actions subtab, then the green New repository secret button on the top right.\n\nAfter adding all the keys, we can run the workflows in our fork. It's a good idea to run tests in our fork CI before opening a pull request on the official Comet repository. If our branch is up to date, all passing tests in the fork CI will result in passing tests in the pull request to main.\n\nThen, we click the Actions tab again and select the Run Scenarios workflow on the left. We click the Run workflow button on the right, select our branch in the dropdown menu, and then click the green Run workflow button. It will take several minutes to run. Our scenario might not succeed on all instances of Comet because the ZRX token and Chainlink price feed smart contracts are nonexistent at the specified address on other chains than Ethereum mainnet.\n\nLastly, we should consider that scenarios will check existing pending on-chain governance proposals against the test to make sure there are no conflicts caused. This might be the cause of a failing scenario that previously succeeded, even when no code changes have been made in the interim.\n\nNow that we know how to write a scenario test, run it locally, and run it in CI, we can delete this branch and apply what we learned to a Compound III migration script.",
      "name": "Add tests and run CI",
      "stepItems": [],
      "uuid": "20bda8f8-ca1a-4bc8-bdde-815d71401f36"
    },
    {
      "content": "Migrations are scripts that are used to deploy or modify contracts in a systematic way. The purpose of migration scripts is to make sure that users can see potential changes that are run prior to creating a governance proposal. In other words, it's a way to prepare for governance changes by showing everyone what changes will be made to the code before actually implementing them.\n\nTo create a migration, you can use the command `yarn hardhat gen:migration` followed by the network and deployment options. There are two steps to a migration script: prepare, which creates artifacts like new on-chain contracts, and enact, which makes these artifacts current, such as upgrading the proxy to the address from the previous step.\n\nYou can run a migration locally using `yarn hardhat migrate` and specifying the network, deployment, and whether to prepare or enact the migration. You can also simulate either of the previous steps without actually modifying the on-chain state.\n\nThe preferred way to run a migration is in GitHub, via manual workflow dispatch, which allows everyone to see the exact code that was deployed or run. After preparation, a migration stores some artifacts which can be loaded and referenced in the enact step of that migration.\n\nOnce a migration has been created, the next step is to create a pull request on GitHub and get it reviewed, approved, and enacted before merging it. If the migration creates a governance proposal on-chain, then wait until the proposal either executes or fails before merging the pull request.",
      "name": "Migrations",
      "stepItems": [],
      "uuid": "73a81735-14c4-426c-8bd8-950b6e0a2bbf"
    },
    {
      "content": "",
      "name": "Step 5",
      "stepItems": [],
      "uuid": "d9acccfb-0962-4800-aee7-cb9d16494635"
    }
  ],
  "thumbnail": "https://d31h13bdjwgzxs.cloudfront.net/academy/compound/compound_comet.png",
  "uuid": "comet-compound"
}